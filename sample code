/* Smart Safety Jacket - ESP32 main sketch
   Integrates:
   - DS18B20 (OneWire) for body temperature
   - MAX3010x for pulse & SpO2
   - MQ135 gas sensor (analog)
   - BMP180 for atmospheric pressure
   - GPS (NEO-6M) via Serial1
   - SIM800L GSM via Serial2 (SMS alerts)
   - I2C 16x2 LCD display
   - Relay control for Peltier/heater
   - SOS button, buzzer
   This sketch is a best-effort implementation based on the project report.
   Report reference: Smart Safety Jacket project report (PDF). :contentReference[oaicite:10]{index=10}
*/

/* ---------- includes ---------- */
#include <Wire.h>
#include <LiquidCrystal_I2C.h>

#include <OneWire.h>
#include <DallasTemperature.h>

#include <TinyGPSPlus.h>

#include <Adafruit_BMP085.h>       // BMP180 compatible lib
// For MAX3010x you may use Adafruit_MAX30105 or SparkFun library
#include <Adafruit_MAX30105.h>     // adjust if using other implementation

/* ---------- Pin configuration (change if needed) ---------- */
#define PIN_DS18B20        4     // DS18B20 data pin (with 4.7k pull-up)
#define PIN_MQ135_ADC      35    // analog input for MQ135
#define PIN_RELAY          5     // relay control for Peltier/heater
#define PIN_BUZZER         18    // buzzer or alert LED
#define PIN_SOS_BUTTON     19    // SOS button (active LOW)

/* ---------- Serial ports for modules ---------- */
// Serial -> console
// Serial1 -> GPS (NEO-6M)  (RX1, TX1 provided in begin())
// Serial2 -> SIM800L        (RX2, TX2 provided in begin())

// Set pins for Serial1 and Serial2 in setup()

/* ---------- Globals & objects ---------- */
LiquidCrystal_I2C lcd(0x27, 16, 2);    // common I2C address 0x27 (change if 0x3F)
OneWire oneWire(PIN_DS18B20);
DallasTemperature ds18b20(&oneWire);
TinyGPSPlus gps;
Adafruit_BMP085 bmp;
Adafruit_MAX30105 particleSensor;      // MAX30105/30102

// thresholds (tune for real hardware)
const float TEMP_BODY_HIGH = 38.0;   // °C - high body temp threshold
const float TEMP_BODY_LOW  = 34.0;   // °C - low body temp threshold (hypothermia risk)
const int MQ135_THRESHOLD = 400;     // arbitrary ADC threshold — calibrate per sensor
const int SMS_INTERVAL_MS  = 30000;  // send periodic status SMS every 30 seconds

// timing
unsigned long lastSmsMillis = 0;
unsigned long lastSensorMillis = 0;
const unsigned long SENSOR_READ_INTERVAL = 2000;

// SIM800L phone numbers (comma-separated list or single)
const char RECIPIENT_NUMBER[] = "+911234567890";  // CHANGE to desired number

// helpers
float lastBodyTemp = 0.0;
float lastBmpTemp  = 0.0;
float lastPressure = 0.0;
int   lastGasVal   = 0;
int   lastHeartRate = 0;
int   lastSpO2 = 0;

bool emergencyActive = false;

/* ---------- Setup ---------- */
void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("SMART SAFETY JACKET - initializing...");

  // I2C devices
  Wire.begin(21, 22); // SDA, SCL

  // LCD
  lcd.init();
  lcd.backlight();
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("Smart Jacket");
  lcd.setCursor(0,1);
  lcd.print("Init...");

  // DS18B20
  ds18b20.begin();

  // BMP180
  if (!bmp.begin()) {
    Serial.println("BMP180 not found!");
    lcd.setCursor(0,1);
    lcd.print("BMP fail");
  } else {
    Serial.println("BMP180 OK");
  }

  // MAX3010x
  if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) {
    Serial.println("MAX3010x not found. Pulse disabled");
    lcd.setCursor(0,1);
    lcd.print("Pulse sensor fail");
  } else {
    Serial.println("MAX3010x found");
    particleSensor.setup(); // default, tune LED currents & sample rate for production
  }

  // configure pins
  pinMode(PIN_RELAY, OUTPUT);
  digitalWrite(PIN_RELAY, LOW); // heater off initially

  pinMode(PIN_BUZZER, OUTPUT);
  digitalWrite(PIN_BUZZER, LOW);

  pinMode(PIN_SOS_BUTTON, INPUT_PULLUP); // active LOW

  // GPS -> Serial1
  // Example pins (change to match wiring)
  Serial1.begin(9600, SERIAL_8N1, 16 /*RX1*/, 17 /*TX1*/);
  Serial.println("GPS Serial1 started");

  // SIM800L -> Serial2
  Serial2.begin(9600, SERIAL_8N1, 26 /*RX2*/, 27 /*TX2*/);
  Serial.println("SIM800L Serial2 started");
  delay(1000);

  // Give SIM800L some time to boot
  sendATcommand("AT");
  delay(200);

  // Initial greeting on LCD
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("System Ready");
  lcd.setCursor(0,1);
  lcd.print("Monitoring...");
}

/* ---------- Helper functions ---------- */

void sendATcommand(const char* cmd, unsigned long timeout = 1000) {
  Serial2.print(cmd);
  Serial2.print("\r\n");
  Serial.print("SIM -> ");
  Serial.println(cmd);

  unsigned long start = millis();
  while (millis() - start < timeout) {
    while (Serial2.available()) {
      String r = Serial2.readString();
      Serial.print("SIM: "); Serial.println(r);
      // Not doing advanced parsing here — for production, parse OK/ERROR, network, etc.
    }
  }
}

void sendSMS(const char* number, const String &message) {
  // Basic SMS send via SIM800L using Serial2
  // Set SMS text mode
  sendATcommand("AT+CMGF=1", 500);
  delay(100);
  // Set recipient
  Serial2.print("AT+CMGS=\"");
  Serial2.print(number);
  Serial2.print("\"\r\n");
  delay(200);
  Serial2.print(message);
  // End with Ctrl+Z
  Serial2.write(0x1A);
  Serial.println("SMS sent command");
  // allow some time
  delay(2000);
}

String createStatusMessage() {
  char buf[256];
  String gpsPart = "NoGPS";
  if (gps.location.isValid()) {
    gpsPart = String(gps.location.lat(), 6) + "," + String(gps.location.lng(), 6);
  }
  snprintf(buf, sizeof(buf),
           "Jacket Status:\nT:%.1fC HR:%d SpO2:%d Gas:%d GPS:%s",
           lastBodyTemp, lastHeartRate, lastSpO2, lastGasVal, gpsPart.c_str());
  return String(buf);
}

void alertEmergency(const char* reason) {
  emergencyActive = true;
  Serial.print("EMERGENCY: ");
  Serial.println(reason);
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("EMERGENCY!");
  lcd.setCursor(0,1);
  lcd.print(reason);

  // Activate buzzer/LED
  for (int i=0; i<5; i++) {
    digitalWrite(PIN_BUZZER, HIGH);
    delay(200);
    digitalWrite(PIN_BUZZER, LOW);
    delay(200);
  }

  // Send SMS
  String msg = String("EMERGENCY: ") + reason + "\n" + createStatusMessage();
  sendSMS(RECIPIENT_NUMBER, msg);

  // Optionally keep the relay turned on for heating if cold emergency
}

/* ---------- Sensor read routines ---------- */

float readBodyTemp() {
  ds18b20.requestTemperatures();
  float temp = ds18b20.getTempCByIndex(0);
  if (temp == DEVICE_DISCONNECTED_C) {
    Serial.println("DS18B20 disconnected");
    return lastBodyTemp; // fallback
  }
  lastBodyTemp = temp;
  return temp;
}

void readBmp() {
  // BMP provides pressure and temp
  lastBmpTemp = bmp.readTemperature();
  lastPressure = bmp.readPressure() / 100.0; // hPa
}

int readGas() {
  int val = analogRead(PIN_MQ135_ADC); // returns 0-4095 on ESP32 ADC
  lastGasVal = val;
  return val;
}

// Placeholder for pulse/SpO2 reading using MAX3010x
// Real implementation should parse buffer & compute heart rate & SpO2
void readPulseSpO2() {
  // This is a simplified placeholder. For production, use an established
  // MAX3010x algorithm (e.g., SparkFun/FastLED-based or Adafruit's examples).
  // Here we set dummy values if sensor not present.
  if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) {
    lastHeartRate = 75;
    lastSpO2 = 98;
    return;
  }

  // A proper approach is beyond the short example — use library examples
  // For now, attempt to read sample and set placeholders:
  lastHeartRate = 76; // replace with real calculation
  lastSpO2 = 97;      // replace with real calculation
}

/* ---------- Control logic ---------- */

void temperatureControl(float bodyTemp) {
  // Simple control: if bodyTemp too low -> turn on heater (relay on),
  // if too high -> turn off heater (or switch to cooling).
  if (bodyTemp < TEMP_BODY_LOW) {
    digitalWrite(PIN_RELAY, HIGH); // turn on heater
    Serial.println("Relay ON (heating)");
  } else if (bodyTemp > TEMP_BODY_HIGH) {
    digitalWrite(PIN_RELAY, LOW); // turn off heater (or enable cooling logic)
    Serial.println("Relay OFF (temp high)");
  } else {
    // comfortable range -> keep off
    digitalWrite(PIN_RELAY, LOW);
  }
}

/* ---------- Main loop ---------- */

void loop() {
  // Poll GPS data
  while (Serial1.available()) {
    char c = Serial1.read();
    gps.encode(c);
  }

  // Read SOS button
  if (digitalRead(PIN_SOS_BUTTON) == LOW) {
    alertEmergency("SOS Pressed");
    delay(1000); // debouncing and avoid multiple triggers
  }

  unsigned long now = millis();
  if (now - lastSensorMillis >= SENSOR_READ_INTERVAL) {
    lastSensorMillis = now;

    // Read sensors
    float bodyT = readBodyTemp();
    readBmp();
    int gas = readGas();
    readPulseSpO2();

    // Update LCD
    lcd.clear();
    lcd.setCursor(0,0);
    lcd.print("T:");
    lcd.print(bodyT,1);
    lcd.print("C ");
    lcd.print("HR:");
    lcd.print(lastHeartRate);

    lcd.setCursor(0,1);
    lcd.print("G:");
    lcd.print(gas);
    lcd.print(" P:");
    lcd.print((int)lastPressure);

    // Emergency checks
    if (bodyT >= TEMP_BODY_HIGH + 0.5) {
      alertEmergency("High Temp");
    } else if (bodyT <= TEMP_BODY_LOW - 0.5) {
      alertEmergency("Low Temp");
    }

    if (gas > MQ135_THRESHOLD) {
      alertEmergency("Gas Detected");
    }

    // temperature control
    temperatureControl(bodyT);

    Serial.printf("Sensors: T=%.1f HR=%d SpO2=%d Gas=%d Pressure=%.1f\n",
                  bodyT, lastHeartRate, lastSpO2, gas, lastPressure);
  }

  // Periodic SMS
  if (now - lastSmsMillis >= SMS_INTERVAL_MS) {
    lastSmsMillis = now;
    String sms = createStatusMessage();
    sendSMS(RECIPIENT_NUMBER, sms);
  }

  // Small sleep to avoid busy loop
  delay(50);
}
